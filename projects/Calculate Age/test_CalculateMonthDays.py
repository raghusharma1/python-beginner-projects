# ********RoostGPT********
"""
Test generated by RoostGPT for test Python-5768-test3 using AI Type  and AI Model 

ROOST_METHOD_HASH=month_days_1396fdc0ba
ROOST_METHOD_SIG_HASH=month_days_5dd3c5e333


```
Scenario 1: Test with a month that has 31 days
Details:
  TestName: test_month_with_31_days
  Description: Verify that the function returns 31 days for months that traditionally have 31 days, regardless of the leap year status.
Execution:
  Arrange: Define the months which have 31 days.
  Act: Call the function month_days for each of these months with leap_year set to both True and False.
  Assert: Check that the function returns 31 for each call.
Validation:
  This test ensures that the function correctly identifies months with 31 days. It is crucial for calendar-related functionalities to maintain accurate day counts, impacting scheduling and date calculations.

Scenario 2: Test with a month that has 30 days
Details:
  TestName: test_month_with_30_days
  Description: Verify that the function returns 30 days for months that traditionally have 30 days, regardless of the leap year status.
Execution:
  Arrange: Define the months which have 30 days.
  Act: Call the function month_days for each of these months with leap_year set to both True and False.
  Assert: Check that the function returns 30 for each call.
Validation:
  This test validates that the function can correctly distinguish months with 30 days, ensuring accurate day counts which are essential for precise date management and event planning.

Scenario 3: Test February in a leap year
Details:
  TestName: test_february_in_leap_year
  Description: Verify that the function returns 29 days for February when the leap_year parameter is True.
Execution:
  Arrange: Set leap_year to True.
  Act: Call the function month_days with month set to 2 and leap_year as True.
  Assert: Check that the function returns 29.
Validation:
  This scenario is critical to verify the function's capability to handle leap year calculations correctly, which is fundamental for any application dealing with annual date calculations, ensuring correctness especially in edge cases like leap years.

Scenario 4: Test February in a non-leap year
Details:
  TestName: test_february_in_non_leap_year
  Description: Verify that the function returns 28 days for February when the leap_year parameter is False.
Execution:
  Arrange: Set leap_year to False.
  Act: Call the function month_days with month set to 2 and leap_year as False.
  Assert: Check that the function returns 28.
Validation:
  This test ensures the function's accuracy in a common scenario, not a leap year, where February should have 28 days. It is essential for maintaining the integrity of annual date calculations across various applications.

Scenario 5: Test with invalid month values
Details:
  TestName: test_invalid_month_values
  Description: Verify that the function handles invalid month inputs gracefully, potentially by raising an error or returning a default value.
Execution:
  Arrange: Prepare a list of invalid month values (e.g., 0, 13, -1, 100).
  Act: Call the function month_days for each invalid month and check how it behaves.
  Assert: Determine if the function raises an error or returns a specific value indicating invalid input.
Validation:
  This test checks the robustness of the function against erroneous inputs, which is crucial for avoiding crashes or incorrect behaviors in larger systems where inputs might not always be controlled or validated beforehand.
```
"""

# ********RoostGPT********
import pytest
import time
from calendar import isleap
from Calculate_Age.calculate import month_days

@pytest.mark.valid
@pytest.mark.positive
class Test_CalculateMonthDays:
    @pytest.mark.smoke
    def test_month_with_31_days(self):
        # Arrange
        months_with_31_days = [1, 3, 5, 7, 8, 10, 12]
        expected_days = 31

        # Act and Assert
        for month in months_with_31_days:
            assert month_days(month, True) == expected_days
            assert month_days(month, False) == expected_days

    @pytest.mark.smoke
    def test_month_with_30_days(self):
        # Arrange
        months_with_30_days = [4, 6, 9, 11]
        expected_days = 30

        # Act and Assert
        for month in months_with_30_days:
            assert month_days(month, True) == expected_days
            assert month_days(month, False) == expected_days

    @pytest.mark.regression
    def test_february_in_leap_year(self):
        # Arrange
        month = 2
        leap_year = True
        expected_days = 29

        # Act
        result = month_days(month, leap_year)

        # Assert
        assert result == expected_days

    @pytest.mark.regression
    def test_february_in_non_leap_year(self):
        # Arrange
        month = 2
        leap_year = False
        expected_days = 28

        # Act
        result = month_days(month, leap_year)

        # Assert
        assert result == expected_days

    @pytest.mark.negative
    def test_invalid_month_values(self):
        # Arrange
        invalid_months = [0, 13, -1, 100]
        expected_error = ValueError

        # Act and Assert
        for month in invalid_months:
            with pytest.raises(expected_error):
                month_days(month, True)
