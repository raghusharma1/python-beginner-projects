# ********RoostGPT********
"""
Test generated by RoostGPT for test python-test5768 using AI Type  and AI Model 

ROOST_METHOD_HASH=who_won_87f5b3664a
ROOST_METHOD_SIG_HASH=who_won_55f93b97b9


### Scenario 1: Player 1 Wins
Details:
  TestName: test_player1_wins
  Description: This test verifies that the function correctly identifies and announces Player 1 as the winner when Player 1 has a higher score than Player 2.
Execution:
  Arrange: Define scores where player1_score is greater than player2_score.
  Act: Call the function who_won with these scores.
  Assert: Check that the output contains "Player 1 won".
Validation:
  This test ensures that the function adheres to the rule that the player with the higher score wins, which is a fundamental requirement of most competitive games.

### Scenario 2: Player 2 Wins
Details:
  TestName: test_player2_wins
  Description: This test ensures that the function correctly identifies and announces Player 2 as the winner when Player 2 has a higher score than Player 1.
Execution:
  Arrange: Define scores where player2_score is greater than player1_score.
  Act: Call the function who_won with these scores.
  Assert: Check that the output contains "Player 2 won".
Validation:
  The test checks the function's ability to determine the winner based on score comparison, which is essential for maintaining the integrity and fairness of the game outcomes.

### Scenario 3: Match Ends in a Draw
Details:
  TestName: test_match_draw
  Description: This test checks if the function accurately identifies and announces a draw when both players have the same score.
Execution:
  Arrange: Define scores where player1_score equals player2_score.
  Act: Call the function who_won with these scores.
  Assert: Check that the output contains "The match ended in a draw".
Validation:
  It's crucial to verify that the function can handle ties correctly since draws are a possible outcome in many competitive scenarios and need to be treated as such.

### Scenario 4: Player 1 Has Negative Score
Details:
  TestName: test_player1_negative_score
  Description: Tests the function's response when Player 1 has a negative score but still higher than Player 2's score.
Execution:
  Arrange: Define scores where player1_score is negative but greater than player2_score (also negative).
  Act: Call the function who_won with these scores.
  Assert: Check that the output contains "Player 1 won".
Validation:
  This scenario ensures that the function can correctly process and compare negative scores, which might occur in games where penalties are possible.

### Scenario 5: Player 2 Has Negative Score
Details:
  TestName: test_player2_negative_score
  Description: Tests the function's response when Player 2 has a negative score and is less than Player 1's positive score.
Execution:
  Arrange: Define scores where player2_score is negative and player1_score is positive.
  Act: Call the function who_won with these scores.
  Assert: Check that the output contains "Player 1 won".
Validation:
  This test is important to confirm that the function handles mixed score types (negative and positive) correctly, ensuring robustness in score comparison logic. 

### Scenario 6: Large Score Values
Details:
  TestName: test_large_score_values
  Description: This test checks the function's performance and correctness with very large score values.
Execution:
  Arrange: Define large integer scores for both players, ensuring one is larger than the other.
  Act: Call the function who_won with these scores.
  Assert: Verify that the function announces the correct player as the winner.
Validation:
  Testing with large values ensures that the function can handle extreme cases, which might be rare but are valid scenarios, especially in automated or long-duration games.
"""

# ********RoostGPT********
import pytest
from HandCricket.main import who_won
from io import StringIO
import sys
import random
import time

class Test_MainWhoWon:
    @pytest.mark.positive
    def test_player1_wins(self, monkeypatch):
        # Arrange
        player1_score = 100
        player2_score = 50
        expected_output = "Player 1 won"
        # Act and Assert
        with monkeypatch.context() as m:
            m.setattr(sys, 'stdout', StringIO())
            who_won(player1_score, player2_score)
            output = sys.stdout.getvalue()
            assert expected_output in output

    @pytest.mark.positive
    def test_player2_wins(self, monkeypatch):
        # Arrange
        player1_score = 30
        player2_score = 80
        expected_output = "Player 2 won"
        # Act and Assert
        with monkeypatch.context() as m:
            m.setattr(sys, 'stdout', StringIO())
            who_won(player1_score, player2_score)
            output = sys.stdout.getvalue()
            assert expected_output in output

    @pytest.mark.positive
    def test_match_draw(self, monkeypatch):
        # Arrange
        player1_score = 75
        player2_score = 75
        expected_output = "The match ended in a draw"
        # Act and Assert
        with monkeypatch.context() as m:
            m.setattr(sys, 'stdout', StringIO())
            who_won(player1_score, player2_score)
            output = sys.stdout.getvalue()
            assert expected_output in output

    @pytest.mark.negative
    def test_player1_negative_score(self, monkeypatch):
        # Arrange
        player1_score = -10
        player2_score = -20
        expected_output = "Player 1 won"
        # Act and Assert
        with monkeypatch.context() as m:
            m.setattr(sys, 'stdout', StringIO())
            who_won(player1_score, player2_score)
            output = sys.stdout.getvalue()
            assert expected_output in output

    @pytest.mark.negative
    def test_player2_negative_score(self, monkeypatch):
        # Arrange
        player1_score = 10
        player2_score = -5
        expected_output = "Player 1 won"
        # Act and Assert
        with monkeypatch.context() as m:
            m.setattr(sys, 'stdout', StringIO())
            who_won(player1_score, player2_score)
            output = sys.stdout.getvalue()
            assert expected_output in output

    @pytest.mark.performance
    def test_large_score_values(self, monkeypatch):
        # Arrange
        player1_score = 1000000000
        player2_score = 999999999
        expected_output = "Player 1 won"
        # Act and Assert
        with monkeypatch.context() as m:
            m.setattr(sys, 'stdout', StringIO())
            who_won(player1_score, player2_score)
            output = sys.stdout.getvalue()
            assert expected_output in output

if __name__ == '__main__':
    pytest.main()
