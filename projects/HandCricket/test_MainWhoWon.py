# ********RoostGPT********
"""
Test generated by RoostGPT for test python-test5768 using AI Type  and AI Model 

ROOST_METHOD_HASH=who_won_87f5b3664a
ROOST_METHOD_SIG_HASH=who_won_55f93b97b9


### Scenario 1: Player 1 Wins
Details:
  TestName: test_player1_wins
  Description: This test verifies that the function correctly identifies and announces Player 1 as the winner when Player 1 has a higher score than Player 2.
Execution:
  Arrange: Define scores where player1_score is greater than player2_score.
  Act: Call the function who_won with these scores.
  Assert: Check that the output contains "Player 1 won".
Validation:
  This test ensures that the function adheres to the rule that the player with the higher score wins, which is fundamental to the game's scoring logic.

### Scenario 2: Player 2 Wins
Details:
  TestName: test_player2_wins
  Description: This test ensures the function correctly identifies and announces Player 2 as the winner when Player 2 has a higher score than Player 1.
Execution:
  Arrange: Set player2_score higher than player1_score.
  Act: Invoke who_won with these scores.
  Assert: The expected result is that the output includes "Player 2 won".
Validation:
  Validates that the function properly recognizes the winner based on the scores provided, maintaining the integrity of the competitive aspect of the game.

### Scenario 3: Match Draws
Details:
  TestName: test_match_draw
  Description: Checks if the function correctly identifies a draw when both players have the same score.
Execution:
  Arrange: Assign equal scores to both players.
  Act: Execute who_won with these parameters.
  Assert: Verify that the output states "The match ended in a draw".
Validation:
  This test is crucial for confirming that the game can correctly handle and announce a draw, which is a possible outcome in competitive scenarios.

### Scenario 4: Large Score Values
Details:
  TestName: test_large_score_values
  Description: Ensures that the function can handle and correctly evaluate large integer values for scores without error.
Execution:
  Arrange: Provide very large scores to both players, ensuring one is slightly higher than the other.
  Act: Run who_won with these large values.
  Assert: Confirm that the function outputs the correct winner based on these values.
Validation:
  Validates the robustness of the function in handling large numbers, which might be crucial in games with high scoring systems or long play times.

### Scenario 5: Negative Score Values
Details:
  TestName: test_negative_score_values
  Description: Tests the function's ability to correctly process and evaluate negative scores.
Execution:
  Arrange: Input negative values for both player scores, with one player having a less negative score.
  Act: Call who_won with these scores.
  Assert: Check for the correct winner announcement based on who has the higher (or less negative) score.
Validation:
  This test checks the function's versatility in dealing with unusual scoring scenarios, such as penalties or negative scoring systems, ensuring accurate results in all cases.
"""

# ********RoostGPT********
import pytest
from HandCricket.main import who_won
import random
import time

class Test_MainWhoWon:

    @pytest.mark.positive
    @pytest.mark.smoke
    def test_player1_wins(self, capsys):
        # Arrange
        player1_score = 100
        player2_score = 50
        # Act
        who_won(player1_score, player2_score)
        captured = capsys.readouterr()
        # Assert
        assert "Player 1 won" in captured.out

    @pytest.mark.positive
    @pytest.mark.regression
    def test_player2_wins(self, capsys):
        # Arrange
        player1_score = 30
        player2_score = 90
        # Act
        who_won(player1_score, player2_score)
        captured = capsys.readouterr()
        # Assert
        assert "Player 2 won" in captured.out

    @pytest.mark.negative
    @pytest.mark.smoke
    def test_match_draw(self, capsys):
        # Arrange
        player1_score = 75
        player2_score = 75
        # Act
        who_won(player1_score, player2_score)
        captured = capsys.readouterr()
        # Assert
        assert "The match ended in a draw" in captured.out

    @pytest.mark.performance
    def test_large_score_values(self, capsys):
        # Arrange
        player1_score = 2147483647  # maximum value for a 32-bit signed integer
        player2_score = 2147483646  # slightly less than player1_score
        # Act
        who_won(player1_score, player2_score)
        captured = capsys.readouterr()
        # Assert
        assert "Player 1 won" in captured.out

    @pytest.mark.negative
    @pytest.mark.regression
    def test_negative_score_values(self, capsys):
        # Arrange
        player1_score = -10
        player2_score = -20
        # Act
        who_won(player1_score, player2_score)
        captured = capsys.readouterr()
        # Assert
        assert "Player 1 won" in captured.out

if __name__ == '__main__':
    main()
