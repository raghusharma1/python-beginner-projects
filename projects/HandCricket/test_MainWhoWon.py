# ********RoostGPT********
"""
Test generated by RoostGPT for test python-test5768 using AI Type  and AI Model 

ROOST_METHOD_HASH=who_won_87f5b3664a
ROOST_METHOD_SIG_HASH=who_won_55f93b97b9


### Test Scenarios for the `who_won` Function

#### Scenario 1: Player 1 Wins
Details:
  TestName: test_player1_wins
  Description: Verify that the function identifies Player 1 as the winner when Player 1's score is greater than Player 2's score.
Execution:
  Arrange: Define scores where player1_score > player2_score.
  Act: Call who_won(player1_score, player2_score).
  Assert: Check that the output indicates "Player 1 won".
Validation:
  Rationalize the importance of this test by ensuring that the function correctly handles and announces a win condition for Player 1 based on the game rules.

#### Scenario 2: Player 2 Wins
Details:
  TestName: test_player2_wins
  Description: Verify that the function identifies Player 2 as the winner when Player 2's score is greater than Player 1's score.
Execution:
  Arrange: Define scores where player2_score > player1_score.
  Act: Call who_won(player1_score, player2_score).
  Assert: Check that the output indicates "Player 2 won".
Validation:
  This test confirms that the function accurately recognizes and communicates a win condition for Player 2, aligning with the rules.

#### Scenario 3: Draw Game
Details:
  TestName: test_draw_game
  Description: Verify that the function correctly identifies a draw when both players have the same score.
Execution:
  Arrange: Define scores where player1_score == player2_score.
  Act: Call who_won(player1_score, player2_score).
  Assert: Check that the output indicates "The match ended in a draw".
Validation:
  Validates that the function adheres to game rules by correctly announcing a draw when scores are equal, ensuring fair play and proper result announcement.

#### Scenario 4: Large Score Values
Details:
  TestName: test_large_scores
  Description: Validate the function's behavior with unusually large integer values to ensure it handles large numbers without errors.
Execution:
  Arrange: Define large values for player1_score and player2_score where one is greater.
  Act: Call who_won(player1_score, player2_score).
  Assert: Confirm the function still correctly identifies the winner or if it's a draw.
Validation:
  This test checks the robustness of the function with large inputs, ensuring it remains reliable under extreme conditions.

### Testing Guidelines for `who_won` Function
BEGIN_GUIDELINE
1. Ensure that test cases are designed to run in isolation without dependency on external data or states.
2. Focus on testing the function's ability to handle expected input ranges (positive integers, including zero).
3. Include assertions that specifically check for the correct output strings ("Player 1 won", "Player 2 won", "The match ended in a draw") to ensure the function's output is as expected.
4. Avoid testing with invalid or non-integer inputs as the function's signature explicitly expects integers (testing type handling is not required unless the function specification changes).
5. Tests should capture stdout or use a mocking framework to verify that the correct print statements are executed, as the function's primary output is via print statements.
6. Prepare test cases to handle and expect no exceptions unless modifications are made to the function to raise specific errors under certain conditions.
7. Document each test case clearly, stating its purpose and expected outcome, to maintain clarity and ease of maintenance.
END_GUIDELINE

By following these scenarios and guidelines, tests can be constructed to effectively validate the business logic of the `who_won` function while ensuring robustness and reliability in handling both typical and extreme cases.
"""

# ********RoostGPT********
import pytest
import sys
from io import StringIO
from projects.HandCricket.main import who_won

class Test_MainWhoWon:
    @pytest.mark.positive
    @pytest.mark.smoke
    def test_player1_wins(self, monkeypatch):
        # Arrange
        player1_score = 100
        player2_score = 50
        expected_output = "Player 1 won"

        # Act & Assert
        with monkeypatch.context() as m:
            m.setattr(sys, 'stdout', StringIO())
            who_won(player1_score, player2_score)
            output = sys.stdout.getvalue()
            assert expected_output in output

    @pytest.mark.negative
    @pytest.mark.regression
    def test_player2_wins(self, monkeypatch):
        # Arrange
        player1_score = 30
        player2_score = 80
        expected_output = "Player 2 won"

        # Act & Assert
        with monkeypatch.context() as m:
            m.setattr(sys, 'stdout', StringIO())
            who_won(player1_score, player2_score)
            output = sys.stdout.getvalue()
            assert expected_output in output

    @pytest.mark.valid
    @pytest.mark.regression
    def test_draw_game(self, monkeypatch):
        # Arrange
        player1_score = 70
        player2_score = 70
        expected_output = "The match ended in a draw"

        # Act & Assert
        with monkeypatch.context() as m:
            m.setattr(sys, 'stdout', StringIO())
            who_won(player1_score, player2_score)
            output = sys.stdout.getvalue()
            assert expected_output in output

    @pytest.mark.performance
    @pytest.mark.regression
    def test_large_scores(self, monkeypatch):
        # Arrange
        player1_score = 10**12
        player2_score = 10**12 + 1
        expected_output = "Player 2 won"

        # Act & Assert
        with monkeypatch.context() as m:
            m.setattr(sys, 'stdout', StringIO())
            who_won(player1_score, player2_score)
            output = sys.stdout.getvalue()
            assert expected_output in output

if __name__ == '__main__':
    pytest.main()
