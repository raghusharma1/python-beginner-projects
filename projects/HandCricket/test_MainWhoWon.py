# ********RoostGPT********
"""
Test generated by RoostGPT for test python-test5768 using AI Type  and AI Model 

ROOST_METHOD_HASH=who_won_87f5b3664a
ROOST_METHOD_SIG_HASH=who_won_55f93b97b9


### Scenario 1: Player 1 Wins
Details:
  TestName: test_player1_wins
  Description: This test verifies that the function correctly identifies and announces Player 1 as the winner when Player 1 has a higher score than Player 2.
Execution:
  Arrange: Define scores where player1_score is greater than player2_score.
  Act: Call the function who_won with these scores.
  Assert: Check that the output contains "Player 1 won".
Validation:
  This test ensures that the function adheres to the rule that the player with the higher score wins, which is a fundamental requirement of most competitive games.

### Scenario 2: Player 2 Wins
Details:
  TestName: test_player2_wins
  Description: This test ensures the function correctly identifies and announces Player 2 as the winner when Player 2 has a higher score than Player 1.
Execution:
  Arrange: Set player2_score higher than player1_score.
  Act: Invoke who_won with these parameters.
  Assert: The expected result is that the output includes "Player 2 won".
Validation:
  The test validates that the game's scoring logic correctly identifies the winner based on scores, which is crucial for maintaining the integrity of the game results.

### Scenario 3: Match Draw
Details:
  TestName: test_match_draw
  Description: This test checks if the function accurately identifies and announces a draw when both players have the same score.
Execution:
  Arrange: Assign equal scores to both players.
  Act: Execute who_won with these scores.
  Assert: Confirm that the output states "The match ended in a draw".
Validation:
  It is essential to handle ties correctly in games where scores are used to determine outcomes, ensuring fairness and proper game resolution.

### Scenario 4: Large Scores
Details:
  TestName: test_large_scores
  Description: Tests the function's ability to handle and correctly evaluate large integer scores.
Execution:
  Arrange: Provide very large scores to both players, ensuring one is slightly higher than the other.
  Act: Run who_won with these large scores.
  Assert: Verify that the function still correctly identifies the player with the higher score as the winner.
Validation:
  This scenario checks the robustness of the function with extreme values, ensuring that the function behaves consistently regardless of score magnitude.

### Scenario 5: Negative Scores
Details:
  TestName: test_negative_scores
  Description: Ensures that the function can handle negative scores and still determine the winner or draw correctly.
Execution:
  Arrange: Assign negative values to both scores, with one player having a less negative score (i.e., closer to zero).
  Act: Call who_won with these scores.
  Assert: Check that the function outputs the correct winner or a draw based on who has the higher (or less negative) score.
Validation:
  Negative scores might not be typical in all games, but ensuring that the function can handle such cases increases its versatility and robustness.

### Scenario 6: Zero Scores
Details:
  TestName: test_zero_scores
  Description: Verifies the function's response when both players have a score of zero.
Execution:
  Arrange: Set both player scores to zero.
  Act: Execute who_won with zero scores.
  Assert: The output should indicate a draw.
Validation:
  This test confirms that the function correctly handles the edge case where no points are scored in the game, which can be critical for correctly concluding such matches.
"""

# ********RoostGPT********
import pytest
from HandCricket.main import who_won
import random
import time

class Test_MainWhoWon:
    
    @pytest.mark.positive
    def test_player1_wins(self, capsys):
        # Arrange
        player1_score = 100
        player2_score = 50
        
        # Act
        who_won(player1_score, player2_score)
        
        # Assert
        captured = capsys.readouterr()
        assert "Player 1 won" in captured.out
    
    @pytest.mark.positive
    def test_player2_wins(self, capsys):
        # Arrange
        player1_score = 30
        player2_score = 90
        
        # Act
        who_won(player1_score, player2_score)
        
        # Assert
        captured = capsys.readouterr()
        assert "Player 2 won" in captured.out
    
    @pytest.mark.positive
    def test_match_draw(self, capsys):
        # Arrange
        player1_score = 75
        player2_score = 75
        
        # Act
        who_won(player1_score, player2_score)
        
        # Assert
        captured = capsys.readouterr()
        assert "The match ended in a draw" in captured.out
    
    @pytest.mark.performance
    def test_large_scores(self, capsys):
        # Arrange
        player1_score = 1000000
        player2_score = 999999
        
        # Act
        who_won(player1_score, player2_score)
        
        # Assert
        captured = capsys.readouterr()
        assert "Player 1 won" in captured.out
    
    @pytest.mark.negative
    def test_negative_scores(self, capsys):
        # Arrange
        player1_score = -10
        player2_score = -20
        
        # Act
        who_won(player1_score, player2_score)
        
        # Assert
        captured = capsys.readouterr()
        assert "Player 1 won" in captured.out
    
    @pytest.mark.negative
    def test_zero_scores(self, capsys):
        # Arrange
        player1_score = 0
        player2_score = 0
        
        # Act
        who_won(player1_score, player2_score)
        
        # Assert
        captured = capsys.readouterr()
        assert "The match ended in a draw" in captured.out

if __name__ == '__main__':
    pytest.main()
