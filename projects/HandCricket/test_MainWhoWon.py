# ********RoostGPT********
"""
Test generated by RoostGPT for test python-test5768 using AI Type  and AI Model 

ROOST_METHOD_HASH=who_won_87f5b3664a
ROOST_METHOD_SIG_HASH=who_won_55f93b97b9


### Scenario 1: Player 1 Wins
Details:
  TestName: test_player1_wins
  Description: This test verifies that the function correctly identifies and announces Player 1 as the winner when Player 1 has a higher score than Player 2.
Execution:
  Arrange: Define scores where player1_score is greater than player2_score.
  Act: Call the function who_won with these scores.
  Assert: Check that the output contains "Player 1 won".
Validation:
  This test ensures that the function adheres to the rule that the player with the higher score wins, which is a fundamental requirement of most competitive games.

### Scenario 2: Player 2 Wins
Details:
  TestName: test_player2_wins
  Description: This test ensures that the function correctly identifies and announces Player 2 as the winner when Player 2 has a higher score than Player 1.
Execution:
  Arrange: Define scores where player2_score is greater than player1_score.
  Act: Call the function who_won with these scores.
  Assert: Check that the output contains "Player 2 won".
Validation:
  The test confirms the function's ability to determine the winner based on higher scores, which is essential for maintaining the integrity and fairness of the game outcomes.

### Scenario 3: Match Ends in a Draw
Details:
  TestName: test_match_draw
  Description: This test checks that the function accurately identifies and announces a draw when both players have the same score.
Execution:
  Arrange: Define scores where player1_score is equal to player2_score.
  Act: Call the function who_won with these scores.
  Assert: Check that the output contains "The match ended in a draw".
Validation:
  Validating draws is crucial as it impacts how tournaments progress and may affect tie-breaking rules, ensuring the game's fairness and competitiveness.

### Scenario 4: Large Score Values
Details:
  TestName: test_large_scores
  Description: This test checks the function's behavior with very large integer values to ensure that it handles high scores without errors.
Execution:
  Arrange: Define scores with very large values for both players, ensuring one is slightly higher.
  Act: Call the function who_won with these scores.
  Assert: Confirm that the function outputs the correct winner based on the larger score.
Validation:
  It's important to test the function's capability to handle large numbers since the game might involve accumulating high scores, and the function must remain robust and accurate.

### Scenario 5: Zero Scores
Details:
  TestName: test_zero_scores
  Description: This test verifies that the function can correctly handle a scenario where both players have a score of zero and declares it a draw.
Execution:
  Arrange: Define scores where both player1_score and player2_score are zero.
  Act: Call the function who_won with these scores.
  Assert: Check that the output contains "The match ended in a draw".
Validation:
  Testing zero scores is essential to ensure the function's reliability under minimal score conditions, reflecting scenarios like a game starting point or lack of scoring activity.

These scenarios cover a range of typical and edge cases that the function might encounter in a real-world application, ensuring comprehensive testing of its logical decision-making capabilities.
"""

# ********RoostGPT********
import pytest
import random
import time
from HandCricket.main import who_won

class Test_MainWhoWon:
    @pytest.mark.positive
    def test_player1_wins(self, capsys):
        # Arrange
        player1_score = 50
        player2_score = 30
        
        # Act
        who_won(player1_score, player2_score)
        
        # Assert
        captured = capsys.readouterr()
        assert "Player 1 won" in captured.out

    @pytest.mark.positive
    def test_player2_wins(self, capsys):
        # Arrange
        player1_score = 20
        player2_score = 40
        
        # Act
        who_won(player1_score, player2_score)
        
        # Assert
        captured = capsys.readouterr()
        assert "Player 2 won" in captured.out

    @pytest.mark.valid
    def test_match_draw(self, capsys):
        # Arrange
        player1_score = 25
        player2_score = 25
        
        # Act
        who_won(player1_score, player2_score)
        
        # Assert
        captured = capsys.readouterr()
        assert "The match ended in a draw" in captured.out

    @pytest.mark.performance
    def test_large_scores(self, capsys):
        # Arrange
        player1_score = 1000000000
        player2_score = 999999999
        
        # Act
        who_won(player1_score, player2_score)
        
        # Assert
        captured = capsys.readouterr()
        assert "Player 1 won" in captured.out

    @pytest.mark.valid
    def test_zero_scores(self, capsys):
        # Arrange
        player1_score = 0
        player2_score = 0
        
        # Act
        who_won(player1_score, player2_score)
        
        # Assert
        captured = capsys.readouterr()
        assert "The match ended in a draw" in captured.out

if __name__ == '__main__':
    pytest.main()
