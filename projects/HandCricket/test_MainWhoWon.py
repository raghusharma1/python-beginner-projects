# ********RoostGPT********
"""
Test generated by RoostGPT for test python-test5768 using AI Type  and AI Model 

ROOST_METHOD_HASH=who_won_87f5b3664a
ROOST_METHOD_SIG_HASH=who_won_55f93b97b9


### Scenario 1: Player 1 Wins

Details:
  TestName: test_player1_wins
  Description: Verify that the function correctly identifies Player 1 as the winner when Player 1's score is greater than Player 2's score.

Execution:
  Arrange: None.
  Act: Call `who_won` with `player1_score` greater than `player2_score`.
  Assert: Check that the output string contains "Player 1 won".

Validation:
  Rationalize the importance of the test and the expected result's connection to the function's specifications and business requirements. Ensuring that the function correctly identifies the winner is crucial for the integrity of the game's outcome reporting.

### Scenario 2: Player 2 Wins

Details:
  TestName: test_player2_wins
  Description: Verify that the function correctly identifies Player 2 as the winner when Player 2's score is greater than Player 1's score.

Execution:
  Arrange: None.
  Act: Call `who_won` with `player2_score` greater than `player1_score`.
  Assert: Check that the output string contains "Player 2 won".

Validation:
  The test ensures that the game accurately reports Player 2 as the winner when they have a higher score, which is essential for fair play and accurate scoring.

### Scenario 3: The Game Ends in a Draw

Details:
  TestName: test_game_draw
  Description: Verify that the function correctly identifies a draw when both players have the same score.

Execution:
  Arrange: None.
  Act: Call `who_won` with `player1_score` equal to `player2_score`.
  Assert: Check that the output string includes "The match ended in a draw".

Validation:
  Testing for a draw condition is important as it verifies that the game can correctly handle and report games where no single player outperforms the other, maintaining fairness and accuracy in game results.

### Scenario 4: Player 1 has a Negative Score

Details:
  TestName: test_player1_negative_score
  Description: Verify that the function can handle and correctly report the outcome when Player 1 has a negative score but still higher than Player 2.

Execution:
  Arrange: None.
  Act: Call `who_won` with a negative `player1_score` that is higher than `player2_score`.
  Assert: Check that the output string contains "Player 1 won".

Validation:
  This scenario tests the robustness of the function in handling unusual but possible score values, ensuring that the function behaves correctly under all scoring conditions.

### Scenario 5: Player 2 has a Negative Score

Details:
  TestName: test_player2_negative_score
  Description: Verify that the function can handle and correctly report the outcome when Player 2 has a negative score but still higher than Player 1.

Execution:
  Arrange: None.
  Act: Call `who_won` with a negative `player2_score` that is higher than `player1_score`.
  Assert: Check that the output string contains "Player 2 won".

Validation:
  This scenario ensures that the function properly handles negative scores and still correctly determines the winner, crucial for maintaining game integrity regardless of score anomalies.

### Scenario 6: Both Players Have Negative Scores

Details:
  TestName: test_both_negative_scores
  Description: Verify that the function correctly identifies the winner or a draw when both players have negative scores.

Execution:
  Arrange: None.
  Act: Call `who_won` with both players having negative scores, varying who has the higher score or if they are the same.
  Assert: Check that the output string correctly identifies the winner or declares a draw.

Validation:
  This test checks the function's ability to accurately process and report results when both scores are below zero, ensuring comprehensive handling of all score ranges.
"""

# ********RoostGPT********
import pytest
from HandCricket.main import who_won
import random
import time

@pytest.mark.positive
def test_player1_wins():
    # Arrange
    player1_score = random.randint(1, 100)
    player2_score = random.randint(-100, player1_score - 1)
    
    # Act
    result = who_won(player1_score, player2_score)
    
    # Assert
    assert "Player 1 won" in result

@pytest.mark.positive
def test_player2_wins():
    # Arrange
    player2_score = random.randint(1, 100)
    player1_score = random.randint(-100, player2_score - 1)
    
    # Act
    result = who_won(player1_score, player2_score)
    
    # Assert
    assert "Player 2 won" in result

@pytest.mark.positive
def test_game_draw():
    # Arrange
    score = random.randint(-100, 100)
    
    # Act
    result = who_won(score, score)
    
    # Assert
    assert "The match ended in a draw" in result

@pytest.mark.negative
def test_player1_negative_score():
    # Arrange
    player1_score = random.randint(-100, -1)
    player2_score = random.randint(-101, player1_score - 1)
    
    # Act
    result = who_won(player1_score, player2_score)
    
    # Assert
    assert "Player 1 won" in result

@pytest.mark.negative
def test_player2_negative_score():
    # Arrange
    player2_score = random.randint(-100, -1)
    player1_score = random.randint(-101, player2_score - 1)
    
    # Act
    result = who_won(player1_score, player2_score)
    
    # Assert
    assert "Player 2 won" in result

@pytest.mark.negative
def test_both_negative_scores():
    # Arrange
    player1_score = random.randint(-100, -1)
    player2_score = random.randint(-100, -1)
    
    # Act
    result = who_won(player1_score, player2_score)
    
    # Assert
    if player1_score > player2_score:
        assert "Player 1 won" in result
    elif player2_score > player1_score:
        assert "Player 2 won" in result
    else:
        assert "The match ended in a draw" in result

if __name__ == '__main__':
    main()
